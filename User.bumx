machine User 
sees UserContext

variables
	accounts
	register
	login
	
//	logged_in
//	logged_out
	
	users
	admins
	staff
	clients
invariants
      
    /* REQ 1: The system manages a set of registered users. */
	/* However, some users may not have a password as they may not have an account */
	/* e.g: client */
	/* Therefore, we use a subset instead of strict subset here */
	@inv-users-register: users ⊆ USER
	
	/* Registered users is a subset of users */
	@inv-login-sub-login: register ⊆ USER
      
    // Each user has exactly 1 PASSWORD
	// A PASSWORD may be used by many users
	@inv-account: accounts ∈ register → PASSWORD
    
	/* REQ 4: There are three types of users: administrators, staff, and clients */
	/* REQ 5: A registered user can only have one role in the system */
	@inv-user-role: partition(register, admins, staff, clients)
	
	/* Logged in users is a subset of registered users */
	@inv-login-sub-registered: login ⊆ register
	
	
		

//	/* Registered users can have the same passwords. A many to one relationship*/
//    /* @inv-user-password: registered ∈ USER ⇸ PASSWORD */
//    
//	/* REQ 1: The system manages a set of registered users. */
//	/* However, some users may not have a password as they may not have an account */
//	/* e.g: client */
//	/* Therefore, we use a subset instead of strict subset here */
//	@inv-users-register: registered ⊆ USER
//	
//	/* REQ 4: There are three types of users: administrators, staff, and clients */
//	/* REQ 5: A registered user can only have one role in the system */
//	/* Clients, admins and staff are all part of the USER type*/
//	@inv-user-role: partition(registered, admins, staff, clients)
//	
//	/* Users can either be logged in or logged out */
//	@inv-user-login: partition(registered, logged_in, logged_out)
//	
//	/* Logged in users is a subset of registered users. Users are assumed to be registered */
//	@inv-login-sub-registered: logged_in ⊆ registered
//	
//	/* Logged in users is a subset of registered users */
//	/* @inv-login-sub-registered: login ⊆ register */s
//	
//	/* Should we use a total function here */
//	/*Not sure what's the difference between above and below */
//	/* @inv7: inv-user-account: registered ∈ registered → PASSWORD */
//	@inv-user-account: account ∈ USER ⇸ PASSWORD
	
event INITIALISATION
	then
	
		@act-init-users: users ≔ {root_user}
		@act-init-register: register ≔ {root_user}
		@act-init-accounts: accounts ≔ {root_user ↦ root_password}
		@act-init-login: login ≔ ∅
		@act-init-admins: admins ≔ {root_user}
		@act-init-staff: staff ≔ ∅
		@act-init-clients: clients ≔ ∅
		
//		/* REQ 6: The root user is the initial administrator. */
//		@act-init-users: registered ≔ {root_user}
//		@act-init-admins: admins ≔ {root_user}
//		@act-init-account: account ≔ {root_user ↦ root_password}
//		@act-init-logged-out: logged_out ≔ ∅
//		@act-init-logged-in: logged_in ≔ ∅
	end

	/* REQ 8: A client can register an account with the system directly. */
	event RegisterClient
	any
		client
		pass
	where
		@grd1: client ∈ USER
		@grd2: pass ∈ PASSWORD
		@check-unregistered: client ∉ register
	then
		@add-user: users ≔ users ∪ {client}
		@add-register: register ≔ register ∪ {client}
		@add-client: clients ≔ clients ∪ {client}
		@add-account: accounts ≔ accounts ∪ {client ↦ pass}
	end
	
	/* REQ 2: The system should only allow a user to log in to the system using the correct password. */
	event LoginUser
	any
		user
		pass 
	where
		@check-registered: user ∈ register
		@check-password: pass = accounts(user)
		@check-not-loggedin: user ∉ login
	then
		@add-login: login ≔ login ∪ {user}
	end
	
	/* REQ 3: A logged-in user can log out of the system. */
	event LogoutUser
	any
		user
		pass
	where
		@check-loggedin: user ∈ login
		@check-password: pass = accounts(user)
	then
		@remove-login: login ≔ login ∖ {user}
	end
	
	/* REQ 9: A logged-in user can change their password. */
	event ChangeUserPassword
	any
		user
		old_pass
		new_pass
	where
		@check-user: user ∈ register
		@check-password: old_pass = accounts(user)
		@new-password-type: new_pass ∈ PASSWORD
		@check-loggedin: user ∈ login
	then
		/** Change the password for user everywhere */
		@act3: accounts(user) ≔ new_pass
	end
end

